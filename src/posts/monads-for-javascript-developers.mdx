---
title: Monads for JavaScript developers
slug: /monads-for-javascript-developers
date: 2020-08-11
---

import { PostPaneLink } from "../components/PostPane"
import { EditorPaneLink } from "../components/EditorPane"

Why are there so many monad articles and tutorials?

Because people like me keep writing them. Part of it is due to the <PostPaneLink mdxId="monad-tutorial-fallacy">Monad tutorial fallacy</PostPaneLink>. Nonetheless, I hope this gives you a gist of what monads are and why people care about them.

Try clicking this dashed underline link above; it will open in a pane. If you are on a computer, you'll find some interactive exercises below as well.

I imagine you are familiar with the almighty JavaScript and have encountered types before, maybe with TypeScript or Flow. If not, the code examples should still be intelligible. No Haskell experience required!

# Building intuition with JavaScript

Let's pretend for a moment that JavaScript is a pure language and <PostPaneLink mdxId="side-effects">side-effects</PostPaneLink> are not allowed in functions.

```tsx
function increment(x: number): number {
  console.log('incrementing'); // side effect not allowed!
  return x + 1;
}
```

How can we implement something similar to `console.log` without side effects? Maybe we could wrap the return value to include a string.

```tsx
function incrementWithLog(x: number): [number, string] {
  return [x + 1, 'incrementing\n'];
}

function main() {
  const valueWithLog = incrementWithLog(0);
  const [value, log] = valueWithLog;
  // value = 1
  // log = 'incrementing\n'
}
```

Notice how we've created a context around the original value. Where we started with `increment` returning a `number`, `incrementWithLog` now returns a "tuple" `[number, string]` where the `string` represents the log message. Let's call this context `WithLog<T>` as `[T, string]` where `T` could be any type. In this example, `incrementWithLog` returns a `WithLog<number>`, with `T` being the `number`.

What if we want to use this function multiple times?

```tsx
function main() {
  const initialValue = 0;
  // smooth sailing with the original increment without log
  return increment(increment(increment(initialValue)));
}

function mainWithLog() {
  const initialValue = 0;
  // each incrementWithLog includes a log
  const [result1, log1] = incrementWithLog(initialValue);
  const [result2, log2] = incrementWithLog(result1);
  const [result3, log3] = incrementWithLog(result2);
  return [result3, log1 + log2 + log3];
}
```

This is okay but there's extra work with dealing with the log message. We need to destructure each return value. We can't just chain calls nicely like we can with `increment`. If we're working with a lot of `WithLog` values, is there a way we make it easier to work with?

Let's introduce a couple new functions. The first is `wrap`, which takes a plain old value and puts it in our context with `''`, representing an empty log.

```tsx
type WithLog<T> = [T, string];

// Put a value into the context
function wrap<T>(value: T): WithLog<T> {
  return [value, ''];
}
```

Our second function `bind` is more complicated. It takes two arguments, a  `WithLog<T>` value and a function with type `T => WithLog<T>`.

```tsx
// Apply a given function to a context value
function bind<T>(
  valueWithLog: WithLog<T>,
  f: T => WithLog<T>
): WithLog<T> {
  const [value, existingLog] = valueWithLog;
  const [newValue, newLog] = f(value);
  return [newValue, existingLog + newLog];
}
```

It calls the given function with the value inside the existing context. It then concats the log strings together to form the new log. You can think of it like appending the new log message onto the existing logs.

Now, it's now your turn. <EditorPaneLink codeId="with-log-monad">Open this exercise</EditorPaneLink> and try implementing `mainWithLog` again using both `wrap` and `bind`.

```tsx
function mainWithLog() {
  const initialValueWithLog = wrap(0);
  const r1 = bind(initialValueWithLog, incrementWithLog);
  const r2 = bind(r1, incrementWithLog);
  return bind(r2, incrementWithLog);
}

// This is identical but on one line.
function mainWithLog2() {
  return bind(bind(bind(wrap(0), incrementWithLog), incrementWithLog), incrementWithLog);
}
```

`mainWithLog2` looks a lot like our original `main` without logs! Note that there isn't any code dealing with the log messages. `wrap` and `bind` take care of that for us.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b01e8416-17f8-4b07-9da0-16c6ebeb9718/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b01e8416-17f8-4b07-9da0-16c6ebeb9718/Untitled.png)

You might notice that both `incrementWithLog` and `wrap` are both valid parameters to the second argument of `bind`.

## Quick recap

And there you go! We just made our own `WithLog` monad. We haven't formalized any of this yet but I hope you have an idea of what monads **feel like**.

We have a context type `WithLog<T> = [T, string]` that augments a value with a string representing log messages. We also defined two functions for working with `WithLog`. `wrap` puts a value in the `WithLog` context. `bind` applies a function `T => WithLog<T>` to a context value `WithLog<T>` to get another context value `WithLog<T>`.

## Why?

Why learn monads? Honestly, because they are known to be hard to learn and that in itself is kinda fun, right? Probably the same reason why I feel compelled to write yet another tutorial.

Are monads useful to a JavaScript developer?

Probably not? I personally don't think monads are that useful for JavaScript developers. However, ideas from functional programming are what inspired frameworks like React. Learning monads and alike gets you comfortable thinking about types at a higher level.

### Haskell

**TL;DR** Any real Haskell program requires the use of monads.

Monads are usually associated with Haskell because they form the building blocks for writing programs. In the example above, we pretended that we couldn't have side effects inside functions. *This is actually true in Haskell!* You can't add `console.log` inside your function.

The core Haskell programming language doesn't have many "features" that you take for granted in other languages. In JavaScript, you can have side effects anywhere. In JavaScript, global and module state is easy.

In most functional programming languages, you don't have imperative statements like you do in popular programming languages like JavaScript, Java, Python, etc. Instead, everything is an expression. In Haskell, the `IO` monad gives programmers the ability to sequence effectful actions. For example, `putStr` (the `console.log` equivalent) has type `String -> IO ()`.

Again, this is not a Haskell tutorial but the high-level picture is that combining monads allows Haskell programmers to add "features" to their programming environment. Our `WithLog` monad adds the feature of logging strings. You can think of monads as "computational context". Haskell programmers get to (have to?) pick and choose what programming features to use.

### Notes

In Haskell, our `wrap` function is called `return`. It's extremely confusing hence why I introduce it as `wrap` in this article. Just know that this is not the real name.

The function (second arg) given to `bind` can return a context value with another embedded type. `bind` has the type `(M<T>, T => M<U>) => M<U>`. I restricted `U = T` in the `bind` example above to reduce the number of type variables. For example, we can do the following.

```tsx
function isEvenWithLog(x: number): WithLog<boolean> {
  return [x % 2 === 0, 'called isEven\n'];
}

function mainWithLog(x: number): WithLog<boolean> {
  return bind(bind(wrap(x), incrementWithLog), isEvenWithLog);
}
```

This is the updated visualization for `bind`.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d53a3660-2754-403b-9835-bdf5740002b6/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d53a3660-2754-403b-9835-bdf5740002b6/Untitled.png)

If you wanted to stop here, I don't blame you. Thanks for sticking it this far! If you like this sort of content, check out my Twitter. The rest of the article defines monads more precisely and gives you more content to understand monads.

# What is a Monad exactly?

Now, that we have interacted with monads, let's get serious and get more precise. Monad is a type class that is defined in Haskell as the following.

```haskell
class Applicative m => Monad m where
  return :: a -> m a
  (>>=)  :: m a -> (a -> m b) -> m b
```

***Huh?*** This isn't a tutorial on Haskell; we want to learn as little Haskell as we need to understand monads. We'll break down the relevant pieces.

Monad is a type class with kind `* -> *`. ***HUH?!?***

The approximate English translation: **Monad is a generic type with exactly one type parameter** that has an associated interface implementation.

If you're familiar with a type system like TypeScript, monads roughly speaking look like `M<A>` where `M` is the monad and `A` is the one type parameter. For example, `Array<A>` has the structure to be a potential monad.

Let's translate the Haskell definition above into loose TypeScript. I've replaced `return` with `wrap` because `return` is a restricted JavaScript keyword. The `>>=` symbol is `bind`.

```tsx
interface MonadImplementation<M<_>> {
  wrap: <A>(A) => M<A>,
  bind: <A, B>(M<A>, A => M<B>) => M<B>,
}
```

Let's revisit our `WithLog` context. Here, we plug in our implementation for `wrap` and `bind`.

```tsx
type WithLog<T> = [T, string];

const WithLogMonadImplementation: MonadImplementation<WithLog> = {
  wrap: <A>(x: A): WithLog<A> => [x, ''],
  bind: <A, B>(m: WithLog<A>, f: A => WithLog<B>) => {
    const [value, log] = m;
    const [newValue, newLog] = f(value);
    return [newValue, log + newLog];
  },
};
```

This is the JavaScript implementation of our `WithLog` monad!

## Maybe Monad

The best way to understand monads is to implement one (or a couple). Let's try doing so for the `Maybe` type.

```tsx
type Maybe<T> = { value: T } | undefined;
```

This is a generic type representing potential failure. For example, `Maybe<number>` could either be a `{value: number}` or `undefined` (failure!). <PostPaneLink mdxId="monad-maybe-type">Why didn't I just use `T | undefined`?</PostPaneLink>

Exercise time! Try <EditorPaneLink codeId="monad-maybe">implementing `wrap` and `bind`</EditorPaneLink>.


```tsx
function wrap<T>(v: T): Maybe<T> {
  return { value: v };
}

function bind<T, U>(v: Maybe<T>, f: T => Maybe<U>): Maybe<U> {
  if (v === undefined) {
    return undefined;
  }
  return f(v.value);
}
```

`wrap` is straightforward; it puts the given value into the `Maybe` context. If the given value to `bind` is `undefined` (failure), we just continue failing by returning `undefined`. Otherwise, we call the given function, which will return us another `Maybe` value. Note that calling function `f` might "fail" and return an `undefined`.

If you have a sequence of computations and any of them fails, we want the whole sequence to fail.

[use maybe example]

# Additional stuff

Weâ€™ll keep formalizing what monads are but if this is feeling tedious, remember that these concepts are definitely not necessary in JavaScript!

Just satisfying the types is not enough to call it a monad. It also needs to satisfy a few rules so they act predictably. These are known as the <PostPaneLink mdxId="monad-laws">Monad Laws</PostPaneLink>.

Because working with monads is so common in Haskell, there is syntactic sugar called <PostPaneLink mdxId="monad-do-notation">do notation</PostPaneLink>.

Another way to think about monads is via <PostPaneLink mdxId="monad-join">`join`</PostPaneLink>, a way to smash two "computational contexts" into one. For example, `WithLog<WithLog<T>> => WithLog<T>`. 

## Further Reading
